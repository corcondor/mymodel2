# THEORY4: Compiler-Inspired Machine Learning - æœ€æ–°ç ”ç©¶å‹•å‘ã¨ç ”ç©¶æˆ¦ç•¥

**æœ€çµ‚æ›´æ–°**: 2026-01-30  
**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: Research Survey & Strategyï¼ˆç ”ç©¶èª¿æŸ»ãƒ»æˆ¦ç•¥ï¼‰

---

## ğŸ¯ æœ¬è³‡æ–™ã®ç›®çš„

æœ€æ–°ã®ç ”ç©¶å‹•å‘ï¼ˆ2026å¹´1æœˆarXivï¼‰ã‚’è¸ã¾ãˆã€æˆ‘ã€…ã®ã€Œã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚¤ãƒ³ã‚¹ãƒ‘ã‚¤ã‚¢æ©Ÿæ¢°å­¦ç¿’ã€ç ”ç©¶ã®ä½ç½®ã¥ã‘ã¨æ–°è¦æ€§ã‚’æ˜ç¢ºåŒ–ã™ã‚‹ã€‚

---

## ğŸ“Š æœ€æ–°ç ”ç©¶å‹•å‘ï¼ˆ2026å¹´1æœˆ arXivèª¿æŸ»ï¼‰

### 1. ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© Ã— æ©Ÿæ¢°å­¦ç¿’ã®æœ€å‰ç·š

#### ğŸ”¥ [arXiv:2601.19092] Axe: A Simple Unified Layout Abstraction for Machine Learning Compilers

**æ¦‚è¦**: æ©Ÿæ¢°å­¦ç¿’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ãŸã‚ã®çµ±ä¸€ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæŠ½è±¡åŒ–

**ã‚­ãƒ¼æŠ€è¡“**:
```
ãƒ‡ãƒ¼ã‚¿ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›ã‚’ä¸­é–“è¡¨ç¾ï¼ˆIRï¼‰ã¨ã—ã¦çµ±ä¸€
â†’ ç•°ãªã‚‹ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ï¼ˆGPU, TPU, CPUï¼‰ã«æœ€é©åŒ–
â†’ MLIRï¼ˆMulti-Level IRï¼‰ã®æ€æƒ³ã‚’ç™ºå±•
```

**æˆ‘ã€…ã¨ã®é–¢é€£**:
- âœ… å½¼ã‚‰: NNãƒ¢ãƒ‡ãƒ«ã®å®Ÿè¡Œæœ€é©åŒ–
- ğŸ†• æˆ‘ã€…: **ç”»åƒç‰¹å¾´æŠ½å‡ºã®ãŸã‚ã®IR**ï¼ˆæ§‹æ–‡æœ¨ã€äºŒæ¬¡å½¢å¼ã€ç¾¤æ—¢ç´„è¡¨ç¾ï¼‰

**å·®åˆ¥åŒ–ãƒã‚¤ãƒ³ãƒˆ**:
- Axeã¯ã€Œãƒ¢ãƒ‡ãƒ«å®Ÿè¡Œã€ã®æœ€é©åŒ–
- æˆ‘ã€…ã¯ã€Œç‰¹å¾´æŠ½å‡ºãƒ—ãƒ­ã‚»ã‚¹ã€è‡ªä½“ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¯¾è±¡ã¨ã™ã‚‹ï¼ˆæœªé–‹æ‹“ï¼‰

---

#### [arXiv:2601.17670] Grammar-Aware Literate Generative Mathematical Programming with Compiler-in-the-Loop

**æ¦‚è¦**: æ–‡æ³•èªè­˜ Ã— æ•°ç†æœ€é©åŒ– Ã— ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©çµ±åˆ

**ã‚­ãƒ¼æŠ€è¡“**:
```
æœ€é©åŒ–å•é¡Œè¨˜è¿°è¨€èªï¼ˆDSLï¼‰
â†’ æ–‡æ³•è§£æ
â†’ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã‚‹æœ€é©åŒ–
â†’ ã‚½ãƒ«ãƒãƒ¼å®Ÿè¡Œ
```

**æˆ‘ã€…ã¨ã®é¡ä¼¼æ€§ï¼ˆé‡è¦ï¼ï¼‰**:
```
ã€å½¼ã‚‰ã€‘æ•°å¼ â†’ Parser â†’ IR â†’ æœ€é©åŒ– â†’ ã‚½ãƒ«ãƒãƒ¼
ã€æˆ‘ã€…ã€‘ ç”»åƒ â†’ Parser â†’ IR â†’ æœ€é©åŒ– â†’ Classifier
```

**å·®åˆ¥åŒ–**:
- å½¼ã‚‰: æ•°ç†è¨ˆç”»å•é¡Œï¼ˆORåˆ†é‡ï¼‰
- æˆ‘ã€…: ç”»åƒåˆ†é¡å•é¡Œï¼ˆMLåˆ†é‡ï¼‰+ é›¢æ•£æ¨è«–ä¸­å¿ƒ

---

#### [arXiv:2601.17754] An MLIR Lowering Pipeline for Stencils at Wafer-Scale

**æ¦‚è¦**: MLIRã«ã‚ˆã‚‹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«è¨ˆç®—ã®æœ€é©åŒ–ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

**é–¢é€£æŠ€è¡“**:
- ãƒãƒ«ãƒãƒ¬ãƒ™ãƒ«IRå¤‰æ›
- æœ€é©åŒ–ãƒ‘ã‚¹ï¼ˆphase orderingï¼‰
- ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢å›ºæœ‰ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ

**æˆ‘ã€…ã¸ã®ç¤ºå”†**:
- MLIRã®ã€Œãƒ¬ãƒ™ãƒ«åˆ¥æœ€é©åŒ–ã€ã‚’ç”»åƒç‰¹å¾´æŠ½å‡ºã«é©ç”¨å¯èƒ½
  - Level 1: ãƒ”ã‚¯ã‚»ãƒ« â†’ ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆå­—å¥è§£æï¼‰
  - Level 2: ãƒˆãƒ¼ã‚¯ãƒ³ â†’ æ§‹æ–‡æœ¨ï¼ˆæ§‹æ–‡è§£æï¼‰
  - Level 3: æ§‹æ–‡æœ¨ â†’ IRï¼ˆä¸­é–“è¡¨ç¾ï¼‰
  - Level 4: IR â†’ ç‰¹å¾´ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆã‚³ãƒ¼ãƒ‰ç”Ÿæˆï¼‰

---

### 2. æ±ºå®šæœ¨æœ€é©åŒ–ã®æœ€æ–°å‹•å‘

#### [arXiv:2601.20775] Active Learning for Decision Trees with Provable Guarantees

**æ¦‚è¦**: èƒ½å‹•å­¦ç¿’ã«ã‚ˆã‚‹æ±ºå®šæœ¨æ§‹ç¯‰ã€ç†è«–ä¿è¨¼ä»˜ã

**ã‚­ãƒ¼æŠ€è¡“**:
- ã‚µãƒ³ãƒ—ãƒ«åŠ¹ç‡çš„ãªæœ¨æ§‹ç¯‰
- PACå­¦ç¿’ç†è«–ã«ã‚ˆã‚‹èª¤å·®ä¿è¨¼
- ã‚¯ã‚¨ãƒªé¸æŠæˆ¦ç•¥ã®æœ€é©åŒ–

**æˆ‘ã€…ã¸ã®å¿œç”¨**:
- OCTï¼ˆOptimal Classification Treesï¼‰ã®æ‹¡å¼µæ–¹å‘
- ã€Œã©ã®ç”»åƒã‚’æ¬¡ã«ãƒ©ãƒ™ãƒ«ä»˜ã‘ã™ã¹ãã‹ã€ã‚’æ§‹æ–‡æœ¨ã‹ã‚‰æ¨è«–

---

#### [arXiv:2601.16008] Prioritizing Configuration Relevance via Compiler-Based Refined Feature Ranking

**æ¦‚è¦**: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ™ãƒ¼ã‚¹ã®ç‰¹å¾´é‡é‡è¦åº¦ãƒ©ãƒ³ã‚­ãƒ³ã‚°

**é‡è¦ãªæ´å¯Ÿ**:
```
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®é™çš„è§£æ â†’ ç‰¹å¾´é‡ã®ä¾å­˜é–¢ä¿‚ã‚°ãƒ©ãƒ•
â†’ æœ€é©åŒ–ãƒ‘ã‚¹ã®å½±éŸ¿åº¦åˆ†æ
â†’ ç‰¹å¾´é¸æŠã«æ´»ç”¨
```

**æˆ‘ã€…ã¸ã®ç›´æ¥çš„ç¤ºå”†**:
- ç”»åƒç‰¹å¾´ã®ä¾å­˜é–¢ä¿‚ã‚’æ§‹æ–‡æœ¨ã‹ã‚‰æŠ½å‡º
- Dead Code Eliminationçš„ã«ã€Œåˆ†é¡ã«å¯„ä¸ã—ãªã„ç‰¹å¾´ã€ã‚’é™¤å»
- Common Subexpression Eliminationã§å†—é•·ç‰¹å¾´ã‚’çµ±åˆ

---

### 3. æ§‹é€ åŒ–å­¦ç¿’ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒ è§£æ

#### [arXiv:2601.18987] LLMs versus the Halting Problem: Revisiting Program Termination Prediction

**æ¦‚è¦**: LLMã«ã‚ˆã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ åœæ­¢æ€§åˆ¤å®š

**æˆ‘ã€…ã¨ã®æ€æƒ³çš„é–¢é€£**:
- ãƒ—ãƒ­ã‚°ãƒ©ãƒ  = æ§‹é€ ã‚’æŒã¤ãƒ‡ãƒ¼ã‚¿
- ç”»åƒ = æ§‹é€ ã‚’æŒã¤ãƒ‡ãƒ¼ã‚¿
- æ§‹æ–‡è§£æ + ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯è§£æã®é‡è¦æ€§

---

## ğŸ“š æ—¢å­˜ç ”ç©¶ã¨ã®å·®åˆ¥åŒ–ãƒãƒˆãƒªã‚¯ã‚¹

### ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© Ã— ML ç ”ç©¶

| ç ”ç©¶ | å¯¾è±¡ | IR | æœ€é©åŒ– | æˆ‘ã€…ã®å·®åˆ¥åŒ– |
|------|------|-----|--------|-------------|
| **CompilerGym** (Meta 2021) | ã‚³ãƒ¼ãƒ‰æœ€é©åŒ– | LLVM IR | phase orderingæ¢ç´¢ | ğŸ†• ç”»åƒç‰¹å¾´æŠ½å‡ºã¸ã®é©ç”¨ |
| **Axe** (2026) | NNå®Ÿè¡Œ | Layout IR | ãƒ‡ãƒ¼ã‚¿ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ | ğŸ†• ç‰¹å¾´æŠ½å‡ºãƒ—ãƒ­ã‚»ã‚¹è‡ªä½“ |
| **MLIR** | æ±ç”¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© | Multi-Level IR | éšå±¤çš„ | ğŸ†• é›¢æ•£æ¨è«–ä¸­å¿ƒè¨­è¨ˆ |

### æ§‹é€ åŒ–ç”»åƒç†è§£

| ç ”ç©¶ | æ‰‹æ³• | è¡¨ç¾ | æˆ‘ã€…ã®å·®åˆ¥åŒ– |
|------|------|------|-------------|
| **Scene Grammar** (Zhu) | ç¢ºç‡æ–‡æ³• | Parse Tree | ğŸ†• + ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©æœ€é©åŒ–ãƒ‘ã‚¹ |
| **AOG** (Song 2013) | And-Or Graph | éšå±¤ã‚°ãƒ©ãƒ• | ğŸ†• + IRæœ€é©åŒ–ï¼ˆDCE, CSEï¼‰ |
| **Inverse Graphics** | ç”Ÿæˆãƒ¢ãƒ‡ãƒ«é€†æ¨è«– | Probabilistic Program | ğŸ†• å°DSL + é›¢æ•£æ¢ç´¢ |

### æœ€é©æ±ºå®šæœ¨

| ç ”ç©¶ | æœ€é©åŒ– | ç‰¹å¾´ | æˆ‘ã€…ã®å·®åˆ¥åŒ– |
|------|--------|------|-------------|
| **OCT** (Bertsimas 2017) | MIP | æ‰‹è¨­è¨ˆ | ğŸ†• æ§‹æ–‡æœ¨ã‹ã‚‰è‡ªå‹•ç”Ÿæˆ |
| **Active Learning DT** (2026) | èƒ½å‹•å­¦ç¿’ | æ±ç”¨ | ğŸ†• æ–‡æ³•ãƒ™ãƒ¼ã‚¹ç‰¹å¾´ |

---

## ğŸ¯ æˆ‘ã€…ã®ç ”ç©¶ã®æ–°è¦æ€§ï¼ˆ4ã¤ã®æŸ±ï¼‰

### 1. çµ±ä¸€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å®Œå…¨é©ç”¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å¾“æ¥ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©        â”‚  æˆ‘ã€…ã®ç”»åƒåˆ†é¡ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰           â”‚  ç”Ÿç”»åƒãƒ‡ãƒ¼ã‚¿               â”‚
â”‚       â†“                 â”‚       â†“                    â”‚
â”‚  å­—å¥è§£æ (Lexer)       â”‚  ãƒˆãƒ¼ã‚¯ãƒ³åŒ–                 â”‚
â”‚    â””â†’ ãƒˆãƒ¼ã‚¯ãƒ³åˆ—         â”‚    â””â†’ edge, corner, loop    â”‚
â”‚       â†“                 â”‚       â†“                    â”‚
â”‚  æ§‹æ–‡è§£æ (Parser)      â”‚  æ§‹é€ è§£æ                   â”‚
â”‚    â””â†’ AST               â”‚    â””â†’ æ§‹æ–‡æœ¨ï¼ˆæ–‡æ³•ãƒ™ãƒ¼ã‚¹ï¼‰   â”‚
â”‚       â†“                 â”‚       â†“                    â”‚
â”‚  æ„å‘³è§£æ (Semantic)    â”‚  ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜é©ç”¨           â”‚
â”‚    â””â†’ å‹ä»˜ãAST         â”‚    â””â†’ å¯¾ç§°æ€§ã€ä¿å­˜å‰‡         â”‚
â”‚       â†“                 â”‚       â†“                    â”‚
â”‚  ä¸­é–“ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ         â”‚  IRç”Ÿæˆ                     â”‚
â”‚    â””â†’ Three-Address     â”‚    â””â†’ äºŒæ¬¡å½¢å¼ã€ç¾¤æ—¢ç´„è¡¨ç¾   â”‚
â”‚       â†“                 â”‚       â†“                    â”‚
â”‚  æœ€é©åŒ–                 â”‚  ç‰¹å¾´æœ€é©åŒ–                 â”‚
â”‚    â””â†’ DCE, CSE, ...     â”‚    â””â†’ å®šæ•°é™¤å»ã€å†—é•·é™¤å»     â”‚
â”‚       â†“                 â”‚       â†“                    â”‚
â”‚  ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ             â”‚  ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰                 â”‚
â”‚    â””â†’ ã‚¢ã‚»ãƒ³ãƒ–ãƒª         â”‚    â””â†’ Ridge, LightGBM, OCT  â”‚
â”‚       â†“                 â”‚       â†“                    â”‚
â”‚  æ©Ÿæ¢°èªå®Ÿè¡Œ             â”‚  é«˜é€Ÿæ¨è«– (mmap)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ–°è¦æ€§**:
- âœ… å­—å¥â†’æ§‹æ–‡â†’æ„å‘³â†’IRâ†’æœ€é©åŒ–â†’å®Ÿè¡Œã®**7æ®µéšã™ã¹ã¦**ã‚’å®Ÿè£…
- âœ… Scene Grammarï¼ˆæ§‹æ–‡ã®ã¿ï¼‰ã‚„OCTï¼ˆæœ€é©åŒ–ã®ã¿ï¼‰ã‚’**çµ±åˆ**

---

### 2. æœ€é©åŒ–ãƒ‘ã‚¹æ¢ç´¢: CompilerGymã®ç”»åƒç‰¹å¾´æŠ½å‡ºã¸ã®ç§»æ¤

#### CompilerGymã®ç™ºæƒ³

```python
# CompilerGymã®å•é¡Œè¨­å®š
state = env.reset()
for pass_name in ['mem2reg', 'loop-unroll', 'gvn', ...]:
    state = env.step(pass_name)
# å ±é…¬: ãƒã‚¤ãƒŠãƒªã‚µã‚¤ã‚ºå‰Šæ¸›ã€å®Ÿè¡Œé€Ÿåº¦å‘ä¸Š
```

#### æˆ‘ã€…ã®é©ç”¨

```python
# ç”»åƒç‰¹å¾´æŠ½å‡ºã®phase orderingå•é¡Œ
state = image
for operation in ['edge_detect', 'threshold', 'dilate', 'contour', ...]:
    state = apply_operation(state, operation)
# å ±é…¬: åˆ†é¡ç²¾åº¦ã€è¨ˆç®—åŠ¹ç‡
```

**å•é¡Œã®å®šå¼åŒ–**:

| é …ç›® | CompilerGym | æˆ‘ã€…ï¼ˆææ¡ˆï¼‰ |
|------|-------------|-------------|
| **çŠ¶æ…‹** | LLVM IR | ç”»åƒ + ä¸­é–“è¡¨ç¾ |
| **è¡Œå‹•** | æœ€é©åŒ–ãƒ‘ã‚¹ | ç”»åƒå‡¦ç†æ“ä½œ |
| **å ±é…¬** | ã‚³ãƒ¼ãƒ‰ã‚µã‚¤ã‚ºã€é€Ÿåº¦ | åˆ†é¡ç²¾åº¦ã€CPUæ™‚é–“ |
| **æ¢ç´¢** | RL, ãƒãƒ³ãƒ‡ã‚£ãƒƒãƒˆ | ãƒãƒ³ãƒ‡ã‚£ãƒƒãƒˆã€ç„¼ããªã¾ã—ã€ãƒ“ãƒ¼ãƒ æ¢ç´¢ |

**æ–°è¦æ€§**:
- âŒ æ—¢å­˜ç ”ç©¶: phase orderingã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ã¿
- âœ… æˆ‘ã€…: **ç”»åƒç‰¹å¾´æŠ½å‡ºã‚’ phase ordering å•é¡Œã¨ã—ã¦å®šå¼åŒ–**ï¼ˆä¸–ç•Œåˆï¼‰

**å®Ÿè£…ä¾‹**:

```python
# Phase ordering for image feature extraction
class FeatureExtractionCompiler:
    PASSES = [
        'edge_sobel',      # ã‚¨ãƒƒã‚¸æ¤œå‡ºï¼ˆSobelï¼‰
        'edge_canny',      # ã‚¨ãƒƒã‚¸æ¤œå‡ºï¼ˆCannyï¼‰
        'threshold_otsu',  # é–¾å€¤å‡¦ç†ï¼ˆOtsuï¼‰
        'threshold_fixed', # é–¾å€¤å‡¦ç†ï¼ˆå›ºå®šå€¤ï¼‰
        'morphology_dilate', # è†¨å¼µ
        'morphology_erode',  # åç¸®
        'contour_detect',    # è¼ªéƒ­æ¤œå‡º
        'corner_harris',     # ã‚³ãƒ¼ãƒŠãƒ¼æ¤œå‡º
    ]
    
    def optimize_pass_order(self, X_train, y_train):
        """æœ€é©åŒ–ãƒ‘ã‚¹é †åºã‚’æ¢ç´¢"""
        best_score = 0
        best_order = []
        
        # ãƒ“ãƒ¼ãƒ æ¢ç´¢ or ç„¼ããªã¾ã— or ãƒãƒ³ãƒ‡ã‚£ãƒƒãƒˆ
        for _ in range(n_iterations):
            order = sample_pass_order()
            features = self.apply_passes(X_train, order)
            score = evaluate(features, y_train)
            if score > best_score:
                best_score = score
                best_order = order
        
        return best_order
```

---

### 3. é›¢æ•£æ¨è«–ä¸­å¿ƒ: NNä¸è¦ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

#### æ—¢å­˜ç ”ç©¶ã®å‚¾å‘

```
Scene Grammar â†’ ç¢ºç‡æ¨è«–ï¼ˆã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼‰
Inverse Graphics â†’ VAE, Diffusionï¼ˆNNå¿…é ˆï¼‰
Neural Architecture Search â†’ NNæ§‹é€ æ¢ç´¢
```

#### æˆ‘ã€…ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

```
æ§‹æ–‡æœ¨ â†’ æ•´æ•°ç‰¹å¾´é‡
     â†’ Ridge (ç·šå½¢ã‚½ãƒ«ãƒãƒ¼)
     â†’ LightGBM (æœ¨ãƒ™ãƒ¼ã‚¹)
     â†’ OCT (MIP: æ··åˆæ•´æ•°è¨ˆç”»)
```

**æ–°è¦æ€§**:
- âœ… è¡Œåˆ—æ¼”ç®—ãªã—ï¼ˆå†…ç©ã®ã¿ï¼‰
- âœ… GPUä¸è¦ï¼ˆCPUåŠ¹ç‡çš„ï¼‰
- âœ… æ¨è«–éç¨‹ãŒè«–ç†å¼ã¨ã—ã¦æ¤œè¨¼å¯èƒ½

**åˆ©ç‚¹**:

| é …ç›® | NNç³» | æˆ‘ã€…ï¼ˆé›¢æ•£ï¼‰ |
|------|------|-------------|
| **ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢** | GPUå¿…é ˆ | CPU only |
| **èª¬æ˜å¯èƒ½æ€§** | ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ | æ§‹æ–‡æœ¨ = äººé–“å¯èª­ |
| **æ¤œè¨¼å¯èƒ½æ€§** | å›°é›£ | è«–ç†å¼ã§è¨¼æ˜å¯èƒ½ |
| **ã‚¨ãƒãƒ«ã‚®ãƒ¼** | é«˜æ¶ˆè²» | ä½æ¶ˆè²» |

---

### 4. è¨¼æ˜å¯èƒ½æ€§: å½¢å¼æ‰‹æ³•ã¨ã®èåˆ

#### ãƒ“ã‚¸ãƒ§ãƒ³

```
ç”»åƒåˆ†é¡ã®æ¨è«–éç¨‹ã‚’å½¢å¼æ¤œè¨¼
â†’ ã€Œãªãœã“ã®ç”»åƒãŒ"8"ã¨åˆ¤å®šã•ã‚ŒãŸã‹ã€ã‚’è«–ç†å¼ã§è¨¼æ˜
```

**æŠ€è¡“è¦ç´ **:

1. **æ§‹æ–‡æœ¨ â†’ è«–ç†å¼**
   ```
   parse_tree(image) = Loop(count=2) âˆ§ Endpoint(count=0)
   â†’ classify(image) = "8"
   ```

2. **SMTï¼ˆSatisfiability Modulo Theoriesï¼‰ã‚½ãƒ«ãƒãƒ¼**
   ```python
   from z3 import *
   
   s = Solver()
   s.add(num_loops == 2)
   s.add(num_endpoints == 0)
   s.add(Implies(And(num_loops == 2, num_endpoints == 0), label == 8))
   assert s.check() == sat
   ```

3. **åä¾‹ç”Ÿæˆ**
   ```
   ã€Œ8ã¨èª¤åˆ¤å®šã•ã‚ŒãŸç”»åƒã€ã®æ§‹æ–‡æœ¨ã‚’è§£æ
   â†’ ã€Œãªãœèª¤ã£ãŸã‹ã€ã‚’SMTã‚½ãƒ«ãƒãƒ¼ã§åè¨¼
   ```

**æ–°è¦æ€§**:
- âŒ æ—¢å­˜ML: æ¨è«–éç¨‹ã¯ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
- âœ… æˆ‘ã€…: **æ¨è«–éç¨‹ã‚’å½¢å¼æ¤œè¨¼**ï¼ˆML Ã— å½¢å¼æ‰‹æ³•ã®èåˆï¼‰

---

## ğŸ”¬ å®Ÿè£…è¨ˆç”»ã®ç²¾ç·»åŒ–

### Phase 1: MNIST/Fashion-MNISTï¼ˆæœ€å„ªå…ˆï¼‰

**ç›®æ¨™**: èª¬æ˜å¯èƒ½æ€§ã¨CPUåŠ¹ç‡ã§ã®å‹è² 

#### ã‚¹ãƒ†ãƒƒãƒ—1: Lexerå®Ÿè£…ï¼ˆæ—¢å­˜è³‡ç”£æ´»ç”¨ï¼‰

```python
# æ—¢å­˜ã®mymodel3.pyã‹ã‚‰ç§»æ¤
def lexer_mnist(image):
    tokens = []
    # ã‚¨ãƒƒã‚¸æ¤œå‡º
    edges = edge_map01(image)  # æ—¢å­˜é–¢æ•°
    tokens.extend(extract_edge_tokens(edges))
    
    # LBPï¼ˆLocal Binary Patternï¼‰
    lbp = lbp_hist8(image)  # æ—¢å­˜é–¢æ•°
    tokens.extend(extract_texture_tokens(lbp))
    
    return tokens
```

**æˆæœç‰©**: edge, corner, endpoint ãƒˆãƒ¼ã‚¯ãƒ³åˆ—

---

#### ã‚¹ãƒ†ãƒƒãƒ—2: Parserå®Ÿè£…ï¼ˆ1D CFGï¼‰

```python
# ç°¡æ˜“æ–‡æ³•
GRAMMAR = """
Digit    -> Loop+ | Stroke+
Loop     -> 'O' Position
Stroke   -> '|' Position | '/' Position
Position -> (x, y)
"""

def parser_mnist(tokens):
    tree = ParseTree()
    # ãƒ«ãƒ¼ãƒ—æ¤œå‡º
    loops = detect_loops(tokens)  # é€£çµæˆåˆ†è§£æ
    tree.add_children([Loop(l) for l in loops])
    
    # ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æ¤œå‡º
    strokes = detect_strokes(tokens)  # ç›´ç·šæ¤œå‡º
    tree.add_children([Stroke(s) for s in strokes])
    
    return tree
```

**æˆæœç‰©**: æ§‹æ–‡æœ¨ï¼ˆãƒ«ãƒ¼ãƒ—æ•°ã€ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æ•°ã€äº¤ç‚¹æ•°ï¼‰

---

#### ã‚¹ãƒ†ãƒƒãƒ—3: Semantic Analyzerå®Ÿè£…

```python
def semantic_mnist(tree):
    semantics = {}
    
    # ãƒ«ãƒ¼ãƒ—æ•°ãƒ™ãƒ¼ã‚¹ã®åˆ†é¡è¦å‰‡
    # 0: 1ãƒ«ãƒ¼ãƒ—, 1: 0ãƒ«ãƒ¼ãƒ—, 8: 2ãƒ«ãƒ¼ãƒ—
    semantics['num_loops'] = len(tree.get_loops())
    semantics['num_endpoints'] = len(tree.get_endpoints())
    semantics['num_junctions'] = len(tree.get_junctions())
    
    # å¯¾ç§°æ€§è§£æ
    semantics['has_vertical_symmetry'] = check_symmetry(tree, axis='vertical')
    semantics['has_horizontal_symmetry'] = check_symmetry(tree, axis='horizontal')
    
    return semantics
```

**æˆæœç‰©**: ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜ã‚’åæ˜ ã—ãŸç‰¹å¾´

---

#### ã‚¹ãƒ†ãƒƒãƒ—4: IR Generatorå®Ÿè£…

```python
def generate_ir(semantics):
    # ç·šå½¢ç‰¹å¾´
    linear = [
        semantics['num_loops'],
        semantics['num_endpoints'],
        semantics['num_junctions'],
        int(semantics['has_vertical_symmetry']),
        int(semantics['has_horizontal_symmetry']),
    ]
    
    # äºŒæ¬¡ç‰¹å¾´
    quadratic = []
    for i in range(len(linear)):
        for j in range(i, len(linear)):
            quadratic.append(linear[i] * linear[j])
    
    return np.concatenate([linear, quadratic])
```

**æˆæœç‰©**: ä¸­é–“è¡¨ç¾ï¼ˆç‰¹å¾´ãƒ™ã‚¯ãƒˆãƒ«ï¼‰

---

#### ã‚¹ãƒ†ãƒƒãƒ—5: Optimizerå®Ÿè£…

```python
def optimize_ir(irs):
    X = np.stack([ir.features for ir in irs])
    
    # Pass 1: Dead Code Eliminationï¼ˆå®šæ•°ç‰¹å¾´é™¤å»ï¼‰
    variances = np.var(X, axis=0)
    keep_mask = variances > 1e-8
    X = X[:, keep_mask]
    
    # Pass 2: Common Subexpression Eliminationï¼ˆå†—é•·ç‰¹å¾´é™¤å»ï¼‰
    corr = np.corrcoef(X.T)
    for i in range(len(corr)):
        for j in range(i+1, len(corr)):
            if abs(corr[i, j]) > 0.99:
                keep_mask[j] = False
    X = X[:, keep_mask]
    
    return X, keep_mask
```

**æˆæœç‰©**: æœ€é©åŒ–ã•ã‚ŒãŸç‰¹å¾´ãƒ™ã‚¯ãƒˆãƒ«

---

#### ã‚¹ãƒ†ãƒƒãƒ—6: Code Generatorå®Ÿè£…

```python
def generate_model(X, y, method='ridge'):
    if method == 'ridge':
        from sklearn.linear_model import RidgeClassifier
        model = RidgeClassifier(alpha=1.0)
    elif method == 'oct':
        # TODO: MIPãƒ™ãƒ¼ã‚¹æœ€é©æ±ºå®šæœ¨
        model = OptimalClassificationTree(max_depth=5)
    
    model.fit(X, y)
    return model
```

**æˆæœç‰©**: è¨“ç·´æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«

---

#### æœŸå¾…ç²¾åº¦

| æ‰‹æ³• | ç²¾åº¦ | èª¬æ˜å¯èƒ½æ€§ | CPUåŠ¹ç‡ |
|------|------|-----------|---------|
| CNN | 99%+ | âŒ | âŒï¼ˆGPUå¿…é ˆï¼‰ |
| æˆ‘ã€…ï¼ˆRidgeï¼‰ | 85-92% | âœ… | âœ… |
| æˆ‘ã€…ï¼ˆOCTï¼‰ | 90-95% | âœ…âœ… | âœ… |

**è«–æ–‡çš„ä¾¡å€¤**:
- ç²¾åº¦ã§ã¯å‹ã¦ãªã„ â†’ **èª¬æ˜å¯èƒ½æ€§ãƒ»åŠ¹ç‡æ€§ã§å‹è² **
- ã€Œãªãœã“ã®æ•°å­—ã¨åˆ¤å®šã—ãŸã‹ã€ã‚’æ§‹æ–‡æœ¨ã§èª¬æ˜

---

### Phase 2: CIFAR-10æ‹¡å¼µ

**ç›®æ¨™**: æ—¢å­˜ã®mymodel3.pyã¨ã®çµ±åˆã€75-80%ç²¾åº¦

#### è¿½åŠ è¦ç´ 

1. **ã‚«ãƒ©ãƒ¼å¯¾å¿œLexer**
   ```python
   def lexer_cifar10(image):
       # RGBå„ãƒãƒ£ãƒãƒ«ã§å­—å¥è§£æ
       tokens_r = lexer_channel(image[:,:,0])
       tokens_g = lexer_channel(image[:,:,1])
       tokens_b = lexer_channel(image[:,:,2])
       return merge_tokens([tokens_r, tokens_g, tokens_b])
   ```

2. **è¤‡é›‘æ§‹é€ å¯¾å¿œParser**
   ```python
   # And-Or Graphçš„ãªæ–‡æ³•
   GRAMMAR_CIFAR = """
   Object -> (Part AND Part) OR Primitive
   Part   -> Texture | Shape | Color
   """
   ```

3. **D4å¯¾ç§°æ€§æ´»ç”¨**
   ```python
   def semantic_cifar10(tree):
       # mymodel3.pyã®D4ç¾¤å¹³å‡åŒ–ã‚’çµ±åˆ
       features = extract_features(tree)
       features_d4 = d4_orbit_average(features)
       return features_d4
   ```

---

## ğŸ“Š ç ”ç©¶ã¨ã—ã¦å‹ã¦ã‚‹ã€Œæ”»ã‚ç­‹ã€

### ç­‹1: CompilerGymã®æ€æƒ³ã‚’ç”»åƒç‰¹å¾´æŠ½å‡ºã«ç§»æ¤ï¼ˆä¸–ç•Œåˆï¼‰

**ä¸»å¼µ**:
> ç”»åƒå‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ï¼ˆé–¾å€¤â†’è†¨å¼µâ†’è¼ªéƒ­æ¤œå‡ºâ†’â€¦ï¼‰ã¯ã€
> ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã® phase ordering å•é¡Œã¨åŒå‹ã§ã‚ã‚‹ã€‚

**å®Ÿé¨“è¨ˆç”»**:

1. **ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³**: å›ºå®šé †åºã®ç”»åƒå‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
2. **ææ¡ˆæ‰‹æ³•**: ãƒãƒ³ãƒ‡ã‚£ãƒƒãƒˆ/ç„¼ããªã¾ã—/ãƒ“ãƒ¼ãƒ æ¢ç´¢ã§é †åºæœ€é©åŒ–
3. **è©•ä¾¡æŒ‡æ¨™**: åˆ†é¡ç²¾åº¦ã€è¨ˆç®—æ™‚é–“

**æœŸå¾…ã•ã‚Œã‚‹çµæœ**:
- æœ€é©åŒ–ã«ã‚ˆã‚Š5-10%ã®ç²¾åº¦å‘ä¸Š
- CompilerGymè«–æ–‡ï¼ˆarXiv:2109.08267ï¼‰ã‚’ç”»åƒåˆ†é‡ã«æ‹¡å¼µ

---

### ç­‹2: Scene Grammar/AOGã‚’ã€Œã‚³ãƒ³ãƒ‘ã‚¤ãƒ©IRã€ã¨ã—ã¦æ‰±ã†

**ä¸»å¼µ**:
> Scene Grammarã®æ§‹æ–‡æœ¨ã‚’ä¸­é–“è¡¨ç¾ï¼ˆIRï¼‰ã¨è¦‹ãªã—ã€
> ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©æœ€é©åŒ–æŠ€è¡“ï¼ˆDCE, CSEï¼‰ã‚’é©ç”¨ã™ã‚‹ã€‚

**å…·ä½“ä¾‹**:

| ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©æœ€é©åŒ– | ç”»åƒIRã¸ã®é©ç”¨ |
|-----------------|----------------|
| **Dead Code Elimination** | ã€Œåˆ†é¡ã«å¯„ä¸ã—ãªã„æ§‹æ–‡æœ¨ãƒãƒ¼ãƒ‰ã€ã‚’å‰Šé™¤ |
| **Common Subexpression Elimination** | ã€Œå†—é•·ãªæ§‹é€ ãƒ‘ã‚¿ãƒ¼ãƒ³ã€ã‚’çµ±åˆ |
| **Constant Folding** | ã€Œç”»åƒå†…ã®å®šæ•°é ˜åŸŸã€ã‚’äº‹å‰è¨ˆç®— |
| **Loop Invariant Code Motion** | ã€ŒD4è»Œé“å†…ã§ä¸å¤‰ãªç‰¹å¾´ã€ã‚’å¤–ã«å‡ºã™ |

**å®Ÿé¨“è¨ˆç”»**:
- æœ€é©åŒ–å‰å¾Œã§ç‰¹å¾´ãƒ™ã‚¯ãƒˆãƒ«æ¬¡å…ƒæ•°ã‚’æ¯”è¼ƒ
- ç²¾åº¦ã‚’ç¶­æŒã—ã¤ã¤è¨ˆç®—é‡å‰Šæ¸›ã‚’å®Ÿè¨¼

---

### ç­‹3: é€†ã‚°ãƒ©ãƒ•ã‚£ã‚¯ã‚¹ã‚’å°DSLã«åˆ¶é™ï¼ˆé›¢æ•£æ¨è«–å¯èƒ½åŒ–ï¼‰

**ä¸»å¼µ**:
> Inverse Graphicsã®ç”Ÿæˆãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’
> ã€Œãƒ‰ãƒƒãƒˆãƒ»ç·šåˆ†ãƒ»å††å¼§ã€ã®ã¿ã®å°DSLã«åˆ¶é™ã™ã‚Œã°ã€
> é›¢æ•£æ¢ç´¢ã§æ¨è«–å¯èƒ½ï¼ˆNNä¸è¦ï¼‰ã€‚

**DSLä¾‹**:

```python
# ç”»åƒç”ŸæˆDSL
Program = [
    Dot(x=10, y=20, intensity=255),
    Line(start=(5,5), end=(15,15), width=2),
    Arc(center=(20,20), radius=10, angle_start=0, angle_end=180),
]
```

**æ¨è«–æ‰‹é †**:

1. ç”»åƒã‚’è¦³æ¸¬
2. ã€Œã©ã®DSLãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒç”Ÿæˆã—ãŸã‹ã€ã‚’æ¢ç´¢
3. ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ â†’ ç‰¹å¾´ãƒ™ã‚¯ãƒˆãƒ«

**åˆ©ç‚¹**:
- ãƒ—ãƒ­ã‚°ãƒ©ãƒ ç©ºé–“ãŒé›¢æ•£ â†’ SAT/MIPã§æœ€é©åŒ–å¯èƒ½
- èª¬æ˜å¯èƒ½æ€§â—ï¼ˆç”Ÿæˆãƒ—ãƒ­ã‚°ãƒ©ãƒ  = èª¬æ˜ï¼‰

---

## ğŸ“ è«–æ–‡åŸ·ç­†æˆ¦ç•¥

### ã‚¿ã‚¤ãƒˆãƒ«å€™è£œ

1. **"Compiler-Inspired Machine Learning: A Unified Pipeline from Image Parsing to Classification"**
   - çµ±ä¸€æ€§ã‚’å¼·èª¿

2. **"From Lexer to Classifier: Applying Compiler Optimization to Image Feature Extraction"**
   - ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©æœ€é©åŒ–ã®é©ç”¨ã‚’å¼·èª¿

3. **"Beyond Neural Networks: A Compiler-Based Approach to Explainable Image Classification"**
   - èª¬æ˜å¯èƒ½æ€§ã‚’å¼·èª¿

4. **"Phase Ordering for Image Features: Extending CompilerGym to Visual Recognition"**
   - CompilerGymæ‹¡å¼µã‚’æ˜ç¤º

---

### è«–æ–‡æ§‹æˆæ¡ˆ

#### 1. Introduction

**ä¸»å¼µ**:
- ç¾çŠ¶: NNä¸»æµã ãŒã€èª¬æ˜å›°é›£ãƒ»GPUå¿…é ˆãƒ»ã‚¨ãƒãƒ«ã‚®ãƒ¼å¤§
- ææ¡ˆ: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’ç”»åƒåˆ†é¡ã«çµ±ä¸€é©ç”¨
- è²¢çŒ®: (1) çµ±ä¸€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£, (2) phase orderingç§»æ¤, (3) é›¢æ•£æ¨è«–, (4) å½¢å¼æ¤œè¨¼

---

#### 2. Related Work

**2.1 ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© Ã— æ©Ÿæ¢°å­¦ç¿’**
- CompilerGym (Meta 2021)
- Axe (2026)
- MLIR

**2.2 æ§‹é€ åŒ–ç”»åƒç†è§£**
- Scene Grammar (Zhu & Mumford)
- AOG (Song+ 2013)
- Inverse Graphics (Kulkarni+ 2013)

**2.3 æœ€é©æ±ºå®šæœ¨**
- OCT (Bertsimas & Dunn 2017)
- Active Learning DT (2026)

**å·®åˆ¥åŒ–è¡¨**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç ”ç©¶             â”‚ Lexer      â”‚ Parser     â”‚ æœ€é©åŒ–   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Scene Grammar    â”‚ âœ…         â”‚ âœ…         â”‚ âŒ       â”‚
â”‚ CompilerGym      â”‚ âŒ(ã‚³ãƒ¼ãƒ‰) â”‚ âŒ(ã‚³ãƒ¼ãƒ‰) â”‚ âœ…       â”‚
â”‚ OCT              â”‚ âŒ(æ‰‹è¨­è¨ˆ) â”‚ âŒ         â”‚ âœ…(MIP)  â”‚
â”‚ æˆ‘ã€…ï¼ˆææ¡ˆï¼‰     â”‚ âœ…         â”‚ âœ…         â”‚ âœ…(çµ±åˆ) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### 3. Method

**3.1 Lexer: ãƒˆãƒ¼ã‚¯ãƒ³åŒ–**
- ã‚¨ãƒƒã‚¸ã€ã‚³ãƒ¼ãƒŠãƒ¼ã€ç«¯ç‚¹ã€äº¤ç‚¹ã®æ¤œå‡º
- LBPï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼‰ã€è‰²ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ 

**3.2 Parser: æ§‹æ–‡æœ¨æ§‹ç¯‰**
- 1D CFG / ç°¡æ˜“AOG
- ãƒ«ãƒ¼ãƒ—ã€ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã€äº¤ç‚¹ã®éšå±¤åŒ–

**3.3 Semantic Analyzer: ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜**
- å¯¾ç§°æ€§æ¤œå‡ºï¼ˆD4ç¾¤ï¼‰
- ç‰©ç†åˆ¶ç´„ï¼ˆä¿å­˜å‰‡ï¼‰

**3.4 IR Generator: ä¸­é–“è¡¨ç¾**
- ç·šå½¢ç‰¹å¾´
- äºŒæ¬¡ç‰¹å¾´ï¼ˆç¾¤æ—¢ç´„è¡¨ç¾ï¼‰

**3.5 Optimizer: æœ€é©åŒ–ãƒ‘ã‚¹**
- DCEï¼ˆå®šæ•°ç‰¹å¾´é™¤å»ï¼‰
- CSEï¼ˆå†—é•·ç‰¹å¾´é™¤å»ï¼‰
- Phase orderingæ¢ç´¢

**3.6 Code Generator: ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰**
- Ridge, LightGBM, OCT

---

#### 4. Experiments

**4.1 Phase 1: MNIST**
- ç²¾åº¦: 85-92%
- èª¬æ˜å¯èƒ½æ€§è©•ä¾¡ï¼ˆæ§‹æ–‡æœ¨ã®å¯èª­æ€§ï¼‰
- CPUåŠ¹ç‡ï¼ˆimages/sï¼‰

**4.2 Phase 2: CIFAR-10**
- ç²¾åº¦: 75-80%ï¼ˆmymodel3.pyã¨åŒç­‰ï¼‰
- æœ€é©åŒ–ãƒ‘ã‚¹æ¢ç´¢ã®åŠ¹æœ

**4.3 Phase Orderingå®Ÿé¨“**
- ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ vs æœ€é©åŒ–å¾Œ
- æ¢ç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒï¼ˆãƒãƒ³ãƒ‡ã‚£ãƒƒãƒˆã€ç„¼ããªã¾ã—ã€ãƒ“ãƒ¼ãƒ ï¼‰

**4.4 Ablation Study**
- å„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®å¯„ä¸
  - Lexer only
  - Lexer + Parser
  - Lexer + Parser + Semantic
  - Full pipeline

---

#### 5. Discussion

**5.1 èª¬æ˜å¯èƒ½æ€§**
- æ§‹æ–‡æœ¨ã®å¯è¦–åŒ–ä¾‹
- èª¤åˆ†é¡ã®ãƒ‡ãƒãƒƒã‚°äº‹ä¾‹

**5.2 è¨ˆç®—åŠ¹ç‡**
- GPU vs CPUæ¯”è¼ƒ
- ã‚¨ãƒãƒ«ã‚®ãƒ¼æ¶ˆè²»é‡

**5.3 å½¢å¼æ¤œè¨¼ã®å¯èƒ½æ€§**
- SMTã‚½ãƒ«ãƒãƒ¼ã¨ã®çµ±åˆãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—

---

#### 6. Conclusion

**æˆæœ**:
- ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”»åƒåˆ†é¡ã¸ã®çµ±ä¸€é©ç”¨ã‚’å®Ÿè¨¼
- Phase orderingå•é¡Œã¨ã—ã¦ç‰¹å¾´æŠ½å‡ºã‚’å®šå¼åŒ–ï¼ˆä¸–ç•Œåˆï¼‰
- é›¢æ•£æ¨è«–ã«ã‚ˆã‚‹èª¬æ˜å¯èƒ½ãƒ»æ¤œè¨¼å¯èƒ½ãªML

**ä»Šå¾Œã®èª²é¡Œ**:
- Phase orderingæ¢ç´¢ã®é«˜åº¦åŒ–ï¼ˆRLå°å…¥ï¼‰
- 3Dç”»åƒã€å‹•ç”»ã¸ã®æ‹¡å¼µ
- å½¢å¼æ¤œè¨¼ã®å®Œå…¨å®Ÿè£…

---

## ğŸ“– å‚è€ƒæ–‡çŒ®

### æœ€æ–°ç ”ç©¶ï¼ˆ2026å¹´1æœˆï¼‰

1. **Axe: Machine Learning Compiler IR**  
   arXiv:2601.19092  
   Bohan Hou et al., 2026.

2. **Grammar-Aware Mathematical Programming**  
   arXiv:2601.17670  
   Roberto Rossi, Steven D. Prestwich, 2026.

3. **MLIR Lowering Pipeline for Stencils**  
   arXiv:2601.17754  
   Nicolai Stawinoga et al., 2026.

4. **Active Learning for Decision Trees**  
   arXiv:2601.20775  
   Arshia Soltani Moakhar et al., 2026.

5. **Compiler-Based Feature Ranking**  
   arXiv:2601.16008  
   Federico Bruzzone et al., 2026.

### å¤å…¸çš„åŸºç¤ç ”ç©¶

6. **CompilerGym: Reinforcement Learning for Compiler Optimization**  
   arXiv:2109.08267  
   Chris Cummins et al., Meta AI, 2021.

7. **MLIR: A Compiler Infrastructure for the End of Moore's Law**  
   arXiv:2002.11054  
   Chris Lattner et al., 2020.

8. **A Stochastic Grammar of Images**  
   Foundations and Trends in Computer Graphics and Vision, 2007  
   Song-Chun Zhu, David Mumford.

9. **Discriminatively Trained And-Or Tree Models**  
   CVPR 2013  
   Liang Lin et al.

10. **Approximate Bayesian Image Interpretation**  
    arXiv:1307.0060  
    Tejas D. Kulkarni et al., 2013.

11. **Optimal Classification Trees**  
    Machine Learning, 2017  
    Dimitris Bertsimas, Jack Dunn.

---

## ğŸš€ æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³

### çŸ­æœŸï¼ˆ1-2é€±é–“ï¼‰

1. âœ… **mymodel_compiler.pyå®Ÿè£…**
   - åŸºæœ¬çš„ãªLexerâ†’Parserâ†’IRâ†’Classifierãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
   - MNISTå®Ÿé¨“

2. **Phase orderingå®Ÿé¨“ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—**
   ```python
   # ç°¡æ˜“ç‰ˆphase ordering
   passes = ['edge_sobel', 'threshold_otsu', 'contour']
   for perm in itertools.permutations(passes):
       features = apply_passes(image, perm)
       score = evaluate(features, labels)
   ```

3. **æ§‹æ–‡æœ¨å¯è¦–åŒ–ãƒ„ãƒ¼ãƒ«**
   - Graphvizé€£æº
   - èª¬æ˜å¯èƒ½æ€§ã®ãƒ‡ãƒ¢

---

### ä¸­æœŸï¼ˆ1-2ãƒ¶æœˆï¼‰

1. **OCTå®Ÿè£…**
   - PuLP or Gurobi
   - MIPã«ã‚ˆã‚‹æ±ºå®šæœ¨æœ€é©åŒ–

2. **Phase orderingæ¢ç´¢ã®é«˜åº¦åŒ–**
   - Multi-Armed Bandit
   - ç„¼ããªã¾ã—æ³•
   - ãƒ“ãƒ¼ãƒ æ¢ç´¢

3. **CIFAR-10æ‹¡å¼µ**
   - mymodel3.pyã¨ã®çµ±åˆ
   - D4å¯¾ç§°æ€§ã®æ´»ç”¨

---

### é•·æœŸï¼ˆ3-6ãƒ¶æœˆï¼‰

1. **è«–æ–‡åŸ·ç­†**
   - ICML/NeurIPS/CVPRæŠ•ç¨¿

2. **å½¢å¼æ¤œè¨¼ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—**
   - Z3ã‚½ãƒ«ãƒãƒ¼çµ±åˆ
   - æ¨è«–éç¨‹ã®è¨¼æ˜

3. **ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹åŒ–**
   - GitHubå…¬é–‹
   - ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•´å‚™

---

## ğŸ’¡ çµè«–

### ç ”ç©¶ã®ä½ç½®ã¥ã‘

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ—¢å­˜ç ”ç©¶ã®ã€Œã™ãé–“ã€ã‚’çªãæˆ¦ç•¥                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                  â”‚
â”‚  CompilerGym: ã‚³ãƒ¼ãƒ‰ â†’ æœ€é©åŒ–ãƒ‘ã‚¹æ¢ç´¢              â”‚
â”‚        â†“                                         â”‚
â”‚  ã€æˆ‘ã€…ã€‘: ç”»åƒ â†’ ç‰¹å¾´æŠ½å‡ºãƒ‘ã‚¹æ¢ç´¢ï¼ˆæœªé–‹æ‹“ï¼‰        â”‚
â”‚                                                  â”‚
â”‚  Scene Grammar: ç”»åƒ â†’ æ–‡æ³• â†’ ãƒ‘ãƒ¼ã‚¹              â”‚
â”‚        â†“                                         â”‚
â”‚  ã€æˆ‘ã€…ã€‘: + ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©IRæœ€é©åŒ–ï¼ˆçµ±åˆï¼‰            â”‚
â”‚                                                  â”‚
â”‚  OCT: MIPã§æ±ºå®šæœ¨æœ€é©åŒ–                           â”‚
â”‚        â†“                                         â”‚
â”‚  ã€æˆ‘ã€…ã€‘: è¿°èª = æ§‹æ–‡æœ¨ã‹ã‚‰è‡ªå‹•ç”Ÿæˆï¼ˆçµ±åˆï¼‰        â”‚
â”‚                                                  â”‚
â”‚  Axe/MLIR: ML compilerçµ±ä¸€IR                     â”‚
â”‚        â†“                                         â”‚
â”‚  ã€æˆ‘ã€…ã€‘: ç”»åƒç”¨IRï¼ˆé›¢æ•£ã€èª¬æ˜å¯èƒ½ã€NNä¸è¦ï¼‰       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ–°è¦æ€§ã®4æœ¬æŸ±

1. âœ… **çµ±ä¸€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**: lexerâ†’parserâ†’IRâ†’æœ€é©åŒ–â†’å®Ÿè¡Œ
2. âœ… **Phase orderingç§»æ¤**: CompilerGymã‚’ç”»åƒç‰¹å¾´æŠ½å‡ºã«é©ç”¨
3. âœ… **é›¢æ•£æ¨è«–ä¸­å¿ƒ**: NNä¸è¦ã€CPUåŠ¹ç‡çš„ã€èª¬æ˜å¯èƒ½
4. âœ… **å½¢å¼æ¤œè¨¼å¯èƒ½æ€§**: æ¨è«–éç¨‹ã‚’è«–ç†å¼ã¨ã—ã¦æ¤œè¨¼

### è«–æ–‡ã¨ã—ã¦ã®å‹ã¡ç­‹

- **ç²¾åº¦å‹è² ã¯ã—ãªã„** â†’ èª¬æ˜å¯èƒ½æ€§ãƒ»åŠ¹ç‡æ€§ãƒ»æ¤œè¨¼å¯èƒ½æ€§ã§å‹è² 
- **çµ±åˆæ€§ã‚’å¼·èª¿** â†’ æ—¢å­˜ç ”ç©¶ï¼ˆScene Grammar + OCT + CompilerGymï¼‰ã®çµ±ä¸€
- **å®Ÿè£…ã®ç¾å®Ÿæ€§** â†’ MNISTï¼ˆPhase 1ï¼‰ã¯2é€±é–“ã§å®Ÿè¨¼å¯èƒ½

---

**æœ€çµ‚æ›´æ–°**: 2026-01-30  
**æ¬¡å›æ›´æ–°äºˆå®š**: mymodel_compiler.pyå®Ÿè¡Œçµæœã‚’åæ˜ 
